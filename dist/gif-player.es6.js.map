{"version":3,"file":"gif-player.es6.js","sources":["../src/omggif.js","../src/gif-player.js","../src/index.js"],"sourcesContent":["// (c) Dean McNamee <dean@gmail.com>, 2013.\n//\n// https://github.com/deanm/omggif\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n//\n// omggif is a JavaScript implementation of a GIF 89a encoder and decoder,\n// including animation and compression.  It does not rely on any specific\n// underlying system, so should run in the browser, Node, or Plask.\n\nexport function GifReader(buf) {\n  var p = 0;\n\n  // - Header (GIF87a or GIF89a).\n  if (buf[p++] !== 0x47 ||            buf[p++] !== 0x49 || buf[p++] !== 0x46 ||\n      buf[p++] !== 0x38 || (buf[p++]+1 & 0xfd) !== 0x38 || buf[p++] !== 0x61) {\n    throw \"Invalid GIF 87a/89a header.\";\n  }\n\n  // - Logical Screen Descriptor.\n  var width = buf[p++] | buf[p++] << 8;\n  var height = buf[p++] | buf[p++] << 8;\n  var pf0 = buf[p++];  // <Packed Fields>.\n  var global_palette_flag = pf0 >> 7;\n  var num_global_colors_pow2 = pf0 & 0x7;\n  var num_global_colors = 1 << (num_global_colors_pow2 + 1);\n  var background = buf[p++];\n  buf[p++];  // Pixel aspect ratio (unused?).\n\n  var global_palette_offset = null;\n\n  if (global_palette_flag) {\n    global_palette_offset = p;\n    p += num_global_colors * 3;  // Seek past palette.\n  }\n\n  var no_eof = true;\n\n  var frames = [ ];\n\n  var delay = 0;\n  var transparent_index = null;\n  var disposal = 0;  // 0 - No disposal specified.\n  var loop_count = null;\n\n  this.width = width;\n  this.height = height;\n\n  while (no_eof && p < buf.length) {\n    switch (buf[p++]) {\n      case 0x21:  // Graphics Control Extension Block\n        switch (buf[p++]) {\n          case 0xff:  // Application specific block\n            // Try if it's a Netscape block (with animation loop counter).\n            if (buf[p   ] !== 0x0b ||  // 21 FF already read, check block size.\n                // NETSCAPE2.0\n                buf[p+1 ] == 0x4e && buf[p+2 ] == 0x45 && buf[p+3 ] == 0x54 &&\n                buf[p+4 ] == 0x53 && buf[p+5 ] == 0x43 && buf[p+6 ] == 0x41 &&\n                buf[p+7 ] == 0x50 && buf[p+8 ] == 0x45 && buf[p+9 ] == 0x32 &&\n                buf[p+10] == 0x2e && buf[p+11] == 0x30 &&\n                // Sub-block\n                buf[p+12] == 0x03 && buf[p+13] == 0x01 && buf[p+16] == 0) {\n              p += 14;\n              loop_count = buf[p++] | buf[p++] << 8;\n              p++;  // Skip terminator.\n            } else {  // We don't know what it is, just try to get past it.\n              p += 12;\n              while (true) {  // Seek through subblocks.\n                var block_size = buf[p++];\n                if (block_size === 0) break;\n                p += block_size;\n              }\n            }\n            break;\n\n          case 0xf9:  // Graphics Control Extension\n            if (buf[p++] !== 0x4 || buf[p+4] !== 0)\n              throw \"Invalid graphics extension block.\";\n            var pf1 = buf[p++];\n            delay = buf[p++] | buf[p++] << 8;\n            transparent_index = buf[p++];\n            if ((pf1 & 1) === 0) transparent_index = null;\n            disposal = pf1 >> 2 & 0x7;\n            p++;  // Skip terminator.\n            break;\n\n          case 0xfe:  // Comment Extension.\n            while (true) {  // Seek through subblocks.\n              var block_size = buf[p++];\n              if (block_size === 0) break;\n              // console.log(buf.slice(p, p+block_size).toString('ascii'));\n              p += block_size;\n            }\n            break;\n\n          default:\n            throw \"Unknown graphic control label: 0x\" + buf[p-1].toString(16);\n        }\n        break;\n\n      case 0x2c:  // Image Descriptor.\n        var x = buf[p++] | buf[p++] << 8;\n        var y = buf[p++] | buf[p++] << 8;\n        var w = buf[p++] | buf[p++] << 8;\n        var h = buf[p++] | buf[p++] << 8;\n        var pf2 = buf[p++];\n        var local_palette_flag = pf2 >> 7;\n        var interlace_flag = pf2 >> 6 & 1;\n        var num_local_colors_pow2 = pf2 & 0x7;\n        var num_local_colors = 1 << (num_local_colors_pow2 + 1);\n        var palette_offset = global_palette_offset;\n        var has_local_palette = false;\n        if (local_palette_flag) {\n          var has_local_palette = true;\n          palette_offset = p;  // Override with local palette.\n          p += num_local_colors * 3;  // Seek past palette.\n        }\n\n        var data_offset = p;\n\n        p++;  // codesize\n        while (true) {\n          var block_size = buf[p++];\n          if (block_size === 0) break;\n          p += block_size;\n        }\n\n        frames.push({x: x, y: y, width: w, height: h,\n                     has_local_palette: has_local_palette,\n                     palette_offset: palette_offset,\n                     data_offset: data_offset,\n                     data_length: p - data_offset,\n                     transparent_index: transparent_index,\n                     interlaced: !!interlace_flag,\n                     delay: delay,\n                     disposal: disposal});\n        break;\n\n      case 0x3b:  // Trailer Marker (end of file).\n        no_eof = false;\n        break;\n\n      default:\n        throw \"Unknown gif block: 0x\" + buf[p-1].toString(16);\n    }\n  }\n\n  this.numFrames = function() {\n    return frames.length;\n  };\n\n  this.loopCount = function() {\n    return loop_count;\n  };\n\n  this.frameInfo = function(frame_num) {\n    if (frame_num < 0 || frame_num >= frames.length)\n      throw \"Frame index out of range.\";\n    return frames[frame_num];\n  }\n\n  this.decodeAndBlitFrameRGBA = function(frame_num, pixels) {\n    var frame = this.frameInfo(frame_num);\n    var num_pixels = frame.width * frame.height;\n    var index_stream = new Uint8Array(num_pixels);  // At most 8-bit indices.\n    GifReaderLZWOutputIndexStream(\n        buf, frame.data_offset, index_stream, num_pixels);\n    var palette_offset = frame.palette_offset;\n\n    // NOTE(deanm): It seems to be much faster to compare index to 256 than\n    // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in\n    // the profile, not sure if it's related to using a Uint8Array.\n    var trans = frame.transparent_index;\n    if (trans === null) trans = 256;\n\n    // We are possibly just blitting to a portion of the entire frame.\n    // That is a subrect within the framerect, so the additional pixels\n    // must be skipped over after we finished a scanline.\n    var framewidth  = frame.width;\n    var framestride = width - framewidth;\n    var xleft       = framewidth;  // Number of subrect pixels left in scanline.\n\n    // Output indicies of the top left and bottom right corners of the subrect.\n    var opbeg = ((frame.y * width) + frame.x) * 4;\n    var opend = ((frame.y + frame.height) * width + frame.x) * 4;\n    var op    = opbeg;\n\n    var scanstride = framestride * 4;\n\n    // Use scanstride to skip past the rows when interlacing.  This is skipping\n    // 7 rows for the first two passes, then 3 then 1.\n    if (frame.interlaced === true) {\n      scanstride += width * 4 * 7;  // Pass 1.\n    }\n\n    var interlaceskip = 8;  // Tracking the row interval in the current pass.\n\n    for (var i = 0, il = index_stream.length; i < il; ++i) {\n      var index = index_stream[i];\n\n      if (xleft === 0) {  // Beginning of new scan line\n        op += scanstride;\n        xleft = framewidth;\n        if (op >= opend) { // Catch the wrap to switch passes when interlacing.\n          scanstride = framestride * 4 + width * 4 * (interlaceskip-1);\n          // interlaceskip / 2 * 4 is interlaceskip << 1.\n          op = opbeg + (framewidth + framestride) * (interlaceskip << 1);\n          interlaceskip >>= 1;\n        }\n      }\n\n      if (index === trans) {\n        op += 4;\n      } else {\n        var r = buf[palette_offset + index * 3];\n        var g = buf[palette_offset + index * 3 + 1];\n        var b = buf[palette_offset + index * 3 + 2];\n        pixels[op++] = r;\n        pixels[op++] = g;\n        pixels[op++] = b;\n        pixels[op++] = 255;\n      }\n      --xleft;\n    }\n  };\n}\n\nfunction GifReaderLZWOutputIndexStream(code_stream, p, output, output_length) {\n  var min_code_size = code_stream[p++];\n\n  var clear_code = 1 << min_code_size;\n  var eoi_code = clear_code + 1;\n  var next_code = eoi_code + 1;\n\n  var cur_code_size = min_code_size + 1;  // Number of bits per code.\n  // NOTE: This shares the same name as the encoder, but has a different\n  // meaning here.  Here this masks each code coming from the code stream.\n  var code_mask = (1 << cur_code_size) - 1;\n  var cur_shift = 0;\n  var cur = 0;\n\n  var op = 0;  // Output pointer.\n\n  var subblock_size = code_stream[p++];\n\n  // TODO(deanm): Would using a TypedArray be any faster?  At least it would\n  // solve the fast mode / backing store uncertainty.\n  // var code_table = Array(4096);\n  var code_table = new Int32Array(4096);  // Can be signed, we only use 20 bits.\n\n  var prev_code = null;  // Track code-1.\n\n  while (true) {\n    // Read up to two bytes, making sure we always 12-bits for max sized code.\n    while (cur_shift < 16) {\n      if (subblock_size === 0) break;  // No more data to be read.\n\n      cur |= code_stream[p++] << cur_shift;\n      cur_shift += 8;\n\n      if (subblock_size === 1) {  // Never let it get to 0 to hold logic above.\n        subblock_size = code_stream[p++];  // Next subblock.\n      } else {\n        --subblock_size;\n      }\n    }\n\n    // TODO(deanm): We should never really get here, we should have received\n    // and EOI.\n    if (cur_shift < cur_code_size)\n      break;\n\n    var code = cur & code_mask;\n    cur >>= cur_code_size;\n    cur_shift -= cur_code_size;\n\n    // TODO(deanm): Maybe should check that the first code was a clear code,\n    // at least this is what you're supposed to do.  But actually our encoder\n    // now doesn't emit a clear code first anyway.\n    if (code === clear_code) {\n      // We don't actually have to clear the table.  This could be a good idea\n      // for greater error checking, but we don't really do any anyway.  We\n      // will just track it with next_code and overwrite old entries.\n\n      next_code = eoi_code + 1;\n      cur_code_size = min_code_size + 1;\n      code_mask = (1 << cur_code_size) - 1;\n\n      // Don't update prev_code ?\n      prev_code = null;\n      continue;\n    } else if (code === eoi_code) {\n      break;\n    }\n\n    // We have a similar situation as the decoder, where we want to store\n    // variable length entries (code table entries), but we want to do in a\n    // faster manner than an array of arrays.  The code below stores sort of a\n    // linked list within the code table, and then \"chases\" through it to\n    // construct the dictionary entries.  When a new entry is created, just the\n    // last byte is stored, and the rest (prefix) of the entry is only\n    // referenced by its table entry.  Then the code chases through the\n    // prefixes until it reaches a single byte code.  We have to chase twice,\n    // first to compute the length, and then to actually copy the data to the\n    // output (backwards, since we know the length).  The alternative would be\n    // storing something in an intermediate stack, but that doesn't make any\n    // more sense.  I implemented an approach where it also stored the length\n    // in the code table, although it's a bit tricky because you run out of\n    // bits (12 + 12 + 8), but I didn't measure much improvements (the table\n    // entries are generally not the long).  Even when I created benchmarks for\n    // very long table entries the complexity did not seem worth it.\n    // The code table stores the prefix entry in 12 bits and then the suffix\n    // byte in 8 bits, so each entry is 20 bits.\n\n    var chase_code = code < next_code ? code : prev_code;\n\n    // Chase what we will output, either {CODE} or {CODE-1}.\n    var chase_length = 0;\n    var chase = chase_code;\n    while (chase > clear_code) {\n      chase = code_table[chase] >> 8;\n      ++chase_length;\n    }\n\n    var k = chase;\n\n    var op_end = op + chase_length + (chase_code !== code ? 1 : 0);\n    if (op_end > output_length) {\n      console.log(\"Warning, gif stream longer than expected.\");\n      return;\n    }\n\n    // Already have the first byte from the chase, might as well write it fast.\n    output[op++] = k;\n\n    op += chase_length;\n    var b = op;  // Track pointer, writing backwards.\n\n    if (chase_code !== code)  // The case of emitting {CODE-1} + k.\n      output[op++] = k;\n\n    chase = chase_code;\n    while (chase_length--) {\n      chase = code_table[chase];\n      output[--b] = chase & 0xff;  // Write backwards.\n      chase >>= 8;  // Pull down to the prefix code.\n    }\n\n    if (prev_code !== null && next_code < 4096) {\n      code_table[next_code++] = prev_code << 8 | k;\n      // TODO(deanm): Figure out this clearing vs code growth logic better.  I\n      // have an feeling that it should just happen somewhere else, for now it\n      // is awkward between when we grow past the max and then hit a clear code.\n      // For now just check if we hit the max 12-bits (then a clear code should\n      // follow, also of course encoded in 12-bits).\n      if (next_code >= code_mask+1 && cur_code_size < 12) {\n        ++cur_code_size;\n        code_mask = code_mask << 1 | 1;\n      }\n    }\n\n    prev_code = code;\n  }\n\n  if (op !== output_length) {\n    console.log(\"Warning, gif stream shorter than expected.\");\n  }\n\n  return output;\n}\n","import { GifReader } from './omggif';\n\nexport default function() {\n  const template = document.createElement('template');\n  template.innerHTML = `\n<style>\n  canvas {\n    position: absolute;\n  }\n\n  @keyframes spinner {\n    to {transform: rotate(360deg);}\n  }\n\n  .spinner:before {\n    content: '';\n    box-sizing: border-box;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    width: 20px;\n    height: 20px;\n    margin-top: -10px;\n    margin-left: -10px;\n    border-radius: 50%;\n    border-top: 2px solid #999;\n    border-right: 2px solid transparent;\n    animation: spinner .6s linear infinite;\n  }\n</style>\n<canvas></canvas>\n<div class=\"spinner\"></spinner>\n`;\n\n  class GifPlayer extends HTMLElement {\n    static get observedAttributes() {\n      return [ 'src', 'frame', 'size', 'speed', 'play', 'swipe', 'repeat', 'bounce', 'direction' ];\n    }\n\n    constructor() {\n      super();\n\n      this._speed = 0.5;\n      this._size = 'auto';\n      this._swipe = true;\n      this._repeat = true;\n      this._bounce = false;\n      this._prerender = false;\n      this._direction = 1;\n\n      this._reset();\n\n      this.pausePlaybackBound = this.pausePlayback.bind(this);\n      this.moveBound = this.move.bind(this);\n      this.resumePlaybackBound = this.resumePlayback.bind(this);\n      this.prerenderFramesBound = this.prerenderFrames.bind(this);\n      this.playLoopBound = this.playLoop.bind(this);\n\n      const shadowRoot = this.attachShadow({mode: 'open'});\n      shadowRoot.appendChild(document.importNode(template.content, true));\n\n      this._spinner = shadowRoot.querySelector('.spinner');\n      this._canvas = shadowRoot.querySelector('canvas');\n      this._ctx = this._canvas.getContext('2d');\n    }\n\n    connectedCallback() {\n      this.style.display = 'inline-block';\n      this.style.position = 'relative';\n      this.style.overflow = 'hidden';\n      this.style.cursor = 'col-resize';\n\n      this.addEventListener('touchstart', this.pausePlaybackBound, false);\n      this.addEventListener('touchmove', this.moveBound, false);\n      this.addEventListener('touchend', this.resumePlaybackBound, false);\n\n      this.addEventListener('mouseenter', this.pausePlaybackBound, false);\n      this.addEventListener('mousemove', this.moveBound, false);\n      this.addEventListener('mouseleave', this.resumePlaybackBound, false);\n    }\n\n    disconnectedCallback() {\n      this.removeEventListener('touchstart', this.pausePlaybackBound, false);\n      this.removeEventListener('touchmove', this.moveBound, false);\n      this.removeEventListener('touchend', this.resumePlaybackBound, false);\n\n      this.removeEventListener('mouseenter', this.pausePlaybackBound, false);\n      this.removeEventListener('mousemove', this.moveBound, false);\n      this.removeEventListener('mouseleave', this.resumePlaybackBound, false);\n    }\n\n    attributeChangedCallback(name, oldValue, newValue) {\n      if (oldValue === newValue) return;\n      this[name] = newValue;\n    }\n\n    _reset() {\n      this._frames = [];\n      this._delays = [];\n      this._frame = 0;\n      this._decoded = -1;\n      this._rendered = -1;    // frame last rendered\n    }\n\n    _handleBoolean(name, val) {\n      this['_' + name] = val = (val !== null && val !== undefined) ? true : false;\n      if (val) {\n        this.setAttribute(name, '');\n      } else {\n        this.removeAttribute(name);\n      }\n    }\n\n    get src() { return this._src; }\n    set src(val) {\n      this._src = val;\n      this.load(val);\n    }\n\n    get frame() { return this._frame; }\n    set frame(val) {\n      this._frame = parseInt(val);\n      this.displayFrame(this._frames, this._frame)\n    }\n\n    get size() { return this._size; }\n    set size(val) { this._size = val; }\n\n    get speed() { return this._speed; }\n    set speed(val) { this._speed = parseFloat(val); }\n\n    get swipe() { return this._swipe; }\n    set swipe(val) { this._swipe = val; }\n\n    get play() { return this._play; }\n    set play(val) { this._handleBoolean('play', val); }\n\n    get repeat() { return this._repeat; }\n    set repeat(val) { this._repeat = parseFloat(val); }\n\n    get bounce() { return this._bounce; }\n    set bounce(val) { this._handleBoolean('bounce', val); }\n\n    get direction() { return this._direction; }\n    set direction(val) { this._direction = parseInt(val); }\n\n    get prerender() { return this._prerender; }\n    set prerender(val) { this._prerender = val; }\n\n    get onload() { return this._onload; }\n    set onload(val) { this._onload = val; }\n\n    move(e) {\n      e.preventDefault();\n\n      var clientX;\n      if (e.targetTouches) {\n        clientX = e.targetTouches[0].clientX;\n      } else {\n        clientX = e.clientX;\n      }\n\n      // calculate our relative horizontal position over the element\n      // TODO: cache this, clear on scroll / resize etc...\n      var rect = this.getBoundingClientRect();\n      var x = clientX - rect.left;\n      var position = x / rect.width;\n\n      // ... and which frame should appear there\n      this.frame = Math.round((this._frames.length - 1) * position);\n    }\n\n    load(src) {\n      this._reset();\n\n      this.dispatchEvent(new CustomEvent('gif-loading', { bubbles: true, composed: true, detail: src }));\n      this._spinner.style.display = 'block';\n\n      var options = {\n        method: 'GET',\n        mode: 'cors',\n        cache: 'default'\n      };\n\n      fetch(src, options)\n        .then(resp => resp.arrayBuffer())\n        .then(buf => new Uint8Array(buf))\n        .then(buf => new GifReader(buf))\n        .then(gif => this.process(gif))\n        .then(() => this._spinner.style.display = 'none');\n    }\n\n    process(gif) {\n      this._gif = gif;\n\n      // canvas drawing area always matches the gif size\n      this._canvas.width = gif.width;\n      this._canvas.height = gif.height;\n\n      // but we can change the visual size and position ...\n      var gifRatio = gif.width / gif.height;\n      var eleRatio = this.clientWidth / this.clientHeight;\n\n      this._canvas.style.top = 0;\n      this._canvas.style.left = 0;\n\n      switch (this._size) {\n        case 'auto':\n          this.style.width = gif.width + 'px';\n          this.style.height = gif.height + 'px';\n          break;\n        case 'cover':\n          var width, height;\n          if (gifRatio > eleRatio) {\n            // fit to height, overlap sides\n            width = this.clientHeight * gifRatio;\n            height = this.clientHeight;\n            this._canvas.style.top = 0;\n            this._canvas.style.left = -((width - this.clientWidth) / 2) + 'px';\n          } else {\n            // fit to width, overlap top\n            width = this.clientWidth;\n            height = this.clientWidth / gifRatio;\n            this._canvas.style.top = -((height - this.clientHeight) / 2) + 'px';\n            this._canvas.style.left = 0;\n          }\n          this._canvas.style.width = width + 'px';\n          this._canvas.style.height = height + 'px';\n          break;\n        case 'contain':\n          var width, height;\n          if (gifRatio > eleRatio) {\n            width = this.clientWidth;\n            height = this.clientWidth / gifRatio;\n            this._canvas.style.top = ((this.clientHeight - height) / 2) + 'px';\n            this._canvas.style.left = 0;\n          } else {\n            width = this.clientHeight * gifRatio;\n            height = this.clientHeight;\n            this._canvas.style.top = 0;\n            this._canvas.style.left = ((this.clientWidth - width) / 2) + 'px';\n          }\n          this._canvas.style.width = width + 'px';\n          this._canvas.style.height = height + 'px';\n          break;\n        case 'stretch':\n          this._canvas.style.width = '100%';\n          this._canvas.style.height = '100%';\n          break;\n      }\n\n      var count = gif.numFrames();\n\n      this._decoded = -1;\n      this._delays = new Array(count);\n      this._frames = new Array(count);\n\n      if (this._frame < 0) {\n        this._frame = this._frames.length + this._frame;\n      }\n\n      var e = new CustomEvent('gif-loaded', { bubbles: true, composed: true, detail: gif });\n      this.dispatchEvent(e);\n      if (this._onload) {\n        this._onload(e);\n      }\n\n      if (this._play) {\n        this.start();\n      } else {\n        this.displayFrame(this._frames, this._frame)\n      }\n\n      if (this._prerender) {\n        requestIdleCallback(this.prerenderFramesBound);\n      }\n    }\n\n    start() {\n      this.playing = true;\n      this.playAnimation(this._frames, this._frame);\n    }\n\n    stop() {\n      this.playing = false;\n    }\n\n    pausePlayback(e) {\n      this.paused = true;\n    }\n\n    resumePlayback(e) {\n      this.paused = false;\n      if (this.playing) {\n        this.playAnimation(this._frames, this._frame);\n      }\n    }\n\n    playLoop(timestamp) {\n      this.rafHandle = requestAnimationFrame(this.playLoopBound);\n\n      if (this._rendered != this._frame) {\n        if (this._frames[this._frame]) {\n          this._rendered = this._frame;\n          this._ctx.putImageData(this._frames[this._frame], 0, 0);\n        }\n      }\n    }\n\n    playAnimation(frames, frame) {\n      if (frames.length === 0) return;\n\n      this.renderFrame(frame);\n      setTimeout(() => {\n        if (this.paused) {\n          return;\n        }\n        var frame = this.frame + this._direction;\n        if (frame < 0) {\n          if (this._bounce) {\n            this._direction = 1;\n            frame = 1;\n          } else {\n            frame = this._frames.length - 1;\n          }\n        } else if (frame >= this._frames.length) {\n          if (this._bounce) {\n            this._direction = -1;\n            frame = this._frames.length - 2;\n          } else {\n            frame = 0;\n          }\n        }\n        this.frame = frame;\n        this.playAnimation(this._frames, this._frame);\n      }, this._delays[frame] * (1 / this._speed));\n    }\n\n    next() {\n      this.frame++;\n      if (this.frame >= this._frames.length) {\n        this.frame = 0;\n      }\n      this.render(this.frame);\n    }\n\n    displayFrame(frames, frame) {\n      if (frames.length === 0) return;\n      if (frame >= frames.length) frame = frames.length - 1;\n      if (frame < 0) frame += frames.length;\n\n      this.renderFrame(frame);\n\n      if (this._rendered != frame) {\n        requestAnimationFrame(() => {\n          this._ctx.putImageData(this._frames[frame], 0, 0);\n          this._rendered = frame;\n          this.dispatchEvent(new CustomEvent('gif-frame', { bubbles: true, composed: true, detail: frame }));\n        });\n      }\n    }\n\n    renderFrame(frame) {\n      while (this._decoded < frame) {\n        var curr = this._decoded + 1;\n        var frameInfo = this._gif.frameInfo(curr);\n        var imageData = this._ctx.createImageData(this._gif.width, this._gif.height);\n        if (curr > 0 && frameInfo.disposal < 2) {\n          imageData.data.set(new Uint8ClampedArray(this._frames[curr - 1].data));\n        }\n        this._gif.decodeAndBlitFrameRGBA(curr, imageData.data);\n        this._frames[curr] = imageData;\n        this._delays[curr] = frameInfo.delay * 10;\n        this._decoded = curr;\n      }\n    }\n\n    // pre-emptively render remaining frames during any idle time\n    // https://developers.google.com/web/updates/2015/08/using-requestidlecallback\n    prerenderFrames(deadline) {\n      while (deadline.timeRemaining() > 0 && this._decoded < this._frames.length - 1) {\n        this.renderFrame(this._decoded + 1);\n      }\n\n      // if we ran out of time and still have work todo, schedule another idle callback\n      if (this._decoded < this._frames.length - 1) {\n        requestIdleCallback(this.prerenderBound);\n      }\n    }\n  }\n\n  window.customElements.define('gif-player', GifPlayer);\n}\n","import register from './gif-player';\n\n// shims\nwindow.requestIdleCallback = window.requestIdleCallback ||\n  function (cb) {\n    var start = Date.now();\n    return setTimeout(function() {\n      cb({\n        didTimeout: false,\n        timeRemaining: function() {\n          return Math.max(0, 50 - (Date.now() - start));\n        }\n      });\n    }, 1);\n  }\n\nwindow.cancelIdleCallback = window.cancelIdleCallback ||\n  function (id) {\n    clearTimeout(id);\n  }\n\nif (window.WebComponents && window.WebComponents.ready) {\n  register();\n} else {\n  window.addEventListener('WebComponentsReady', register);\n}\n"],"names":["GifReader","buf","p","width","height","pf0","global_palette_flag","num_global_colors","global_palette_offset","no_eof","frames","delay","transparent_index","disposal","loop_count","length","block_size","pf1","toString","x","y","w","h","pf2","interlace_flag","num_local_colors","palette_offset","has_local_palette","data_offset","push","numFrames","loopCount","frameInfo","frame_num","decodeAndBlitFrameRGBA","pixels","frame","this","num_pixels","index_stream","Uint8Array","trans","framewidth","framestride","xleft","opbeg","opend","op","scanstride","interlaced","interlaceskip","i","il","index","r","g","b","GifReaderLZWOutputIndexStream","code_stream","output","output_length","min_code_size","clear_code","eoi_code","next_code","cur_code_size","code_mask","cur_shift","cur","subblock_size","code_table","Int32Array","prev_code","code","chase_code","chase_length","chase","k","log","template","document","createElement","innerHTML","GifPlayer","HTMLElement","_speed","_size","_swipe","_repeat","_bounce","_prerender","_direction","_reset","pausePlaybackBound","pausePlayback","bind","moveBound","move","resumePlaybackBound","resumePlayback","prerenderFramesBound","prerenderFrames","playLoopBound","playLoop","shadowRoot","attachShadow","mode","appendChild","importNode","content","_spinner","querySelector","_canvas","_ctx","getContext","style","display","position","overflow","cursor","addEventListener","removeEventListener","name","oldValue","newValue","_frames","_delays","_frame","_decoded","_rendered","val","undefined","setAttribute","removeAttribute","_src","load","parseInt","displayFrame","parseFloat","_play","_handleBoolean","_onload","e","preventDefault","clientX","targetTouches","rect","getBoundingClientRect","left","Math","round","src","dispatchEvent","CustomEvent","bubbles","composed","detail","options","then","resp","arrayBuffer","gif","process","_gif","gifRatio","eleRatio","clientWidth","clientHeight","top","count","Array","start","playing","playAnimation","paused","timestamp","rafHandle","requestAnimationFrame","putImageData","renderFrame","render","curr","imageData","createImageData","data","set","Uint8ClampedArray","deadline","timeRemaining","prerenderBound","customElements","define","window","requestIdleCallback","cb","Date","now","setTimeout","max","cancelIdleCallback","id","WebComponents","ready","register"],"mappings":"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"}